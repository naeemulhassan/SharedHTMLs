<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Max-Cut Step-by-Step Demo (Local Search)</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #111a33;
      --text: #e9ecf6;
      --muted: #aab3d3;
      --accent: #7aa2ff;
      --good: #36d399;
      --bad: #f87272;
      --edge: rgba(233,236,246,0.22);
      --edgeCut: rgba(54,211,153,0.85);
      --edgeWeak: rgba(233,236,246,0.10);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 20% 0%, #18224a 0%, var(--bg) 60%);
      color: var(--text);
    }
    .wrap {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
      padding: 16px;
      min-height: 100vh;
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
      overflow: hidden;
    }
    .panel {
      padding: 14px;
      background: rgba(0,0,0,0.10);
      border-bottom: 1px solid rgba(255,255,255,0.07);
    }
    h1 {
      font-size: 18px;
      margin: 0 0 6px 0;
      letter-spacing: 0.2px;
    }
    .sub {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }
    .controls {
      padding: 14px;
      display: grid;
      gap: 12px;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }
    label {
      font-size: 12px;
      color: var(--muted);
    }
    input[type="range"] {
      width: 100%;
    }
    .btns {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(122,162,255,0.12);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: transform .05s ease, background .2s ease, border-color .2s ease, opacity .2s ease;
      user-select: none;
    }
    button:hover { background: rgba(122,162,255,0.18); border-color: rgba(255,255,255,0.18); }
    button:active { transform: translateY(1px); }
    button.secondary { background: rgba(255,255,255,0.06); }
    button.danger { background: rgba(248,114,114,0.12); }
    button:disabled { opacity: 0.45; cursor: not-allowed; }
    .statgrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .stat {
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.10);
    }
    .stat .k { font-size: 11px; color: var(--muted); }
    .stat .v { font-size: 18px; font-weight: 800; margin-top: 2px; }
    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      padding: 0 2px;
    }
    .canvasCard {
      position: relative;
      padding: 0;
      overflow: hidden;
    }
    canvas { display: block; width: 100%; height: 100%; }
    .overlay {
      position: absolute;
      left: 14px;
      top: 14px;
      right: 14px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      pointer-events: none;
    }
    .pill {
      pointer-events: none;
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(6px);
      color: var(--text);
    }
    .pill b { color: var(--accent); }
    .pill .good { color: var(--good); }
    .pill .bad { color: var(--bad); }
    .footer {
      padding: 12px 14px 14px;
      color: var(--muted);
      font-size: 12px;
      border-top: 1px solid rgba(255,255,255,0.07);
      background: rgba(0,0,0,0.08);
    }

    @media (max-width: 980px) {
      .wrap { grid-template-columns: 1fr; }
      .canvasCard { min-height: 520px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="panel">
        <h1>Max-Cut — Step-by-Step Local Search</h1>
        <div class="sub">
          Two-way partition of vertices to maximize crossing edges.
          This demo uses a simple hill-climbing heuristic (best improving single-vertex flip).
        </div>
      </div>

      <div class="controls">
        <div class="row">
          <label>Nodes: <span id="nLabel"></span></label>
          <div style="width: 160px;">
            <input id="nRange" type="range" min="6" max="40" value="16" />
          </div>
        </div>

        <div class="row">
          <label>Edge probability: <span id="pLabel"></span></label>
          <div style="width: 160px;">
            <input id="pRange" type="range" min="5" max="95" value="25" />
          </div>
        </div>

        <div class="row">
          <label>Seed (optional):</label>
          <input id="seedInput" placeholder="e.g. 12345" style="width: 160px; padding: 9px 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: rgba(0,0,0,0.15); color: var(--text);" />
        </div>

        <div class="btns">
          <button id="genBtn">Generate Graph</button>
          <button id="restartBtn" class="secondary">Restart Search</button>
        </div>

        <div class="btns">
          <button id="backBtn" class="secondary">◀ Back</button>
          <button id="nextBtn">Next ▶</button>
        </div>

        <div class="btns">
          <button id="playBtn">Play</button>
          <button id="pauseBtn" class="secondary" disabled>Pause</button>
        </div>

        <div class="statgrid">
          <div class="stat">
            <div class="k">Cut value</div>
            <div class="v" id="cutVal">0</div>
          </div>
          <div class="stat">
            <div class="k">Step</div>
            <div class="v"><span id="stepIdx">0</span> / <span id="stepMax">0</span></div>
          </div>
          <div class="stat" style="grid-column: 1 / -1;">
            <div class="k">Last move</div>
            <div class="v" id="lastMove" style="font-size: 14px; font-weight: 700;">—</div>
          </div>
        </div>

        <div class="hint">
          <b>What you’re seeing:</b> nodes are split into two groups (two colors). Edges that cross the split are highlighted.
          Each “Next” applies the best improving flip (if any). When no improvement exists, you’re at a local optimum.
        </div>
      </div>

      <div class="footer">
        Tip: try higher edge probability for denser graphs; more nodes makes the local search path longer.
      </div>
    </div>

    <div class="card canvasCard">
      <canvas id="cv"></canvas>
      <div class="overlay">
        <div class="pill">Crossing edges are <b>highlighted</b></div>
        <div class="pill">Partitions: <b>A</b> vs <b>B</b></div>
        <div class="pill">Move picks best Δcut ≥ <span class="good">+1</span></div>
      </div>
    </div>
  </div>

<script>
/* ---------------------------
   Deterministic RNG (optional)
--------------------------- */
function mulberry32(seed) {
  let a = seed >>> 0;
  return function() {
    a |= 0; a = (a + 0x6D2B79F5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function hashStringToSeed(s) {
  // simple 32-bit hash
  let h = 2166136261 >>> 0;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

/* ---------------------------
   Graph + MaxCut local search
--------------------------- */
let G = null;        // { n, edges: [{u,v}], pos: [{x,y}] }
let steps = [];      // history of states
let stepPtr = 0;
let playing = false;
let playTimer = null;

function generateGraph(n, p, rng) {
  // positions on circle (plus tiny jitter)
  const pos = [];
  const cx = 0.5, cy = 0.5;
  const r = 0.38;
  for (let i = 0; i < n; i++) {
    const ang = (i / n) * Math.PI * 2;
    const jitter = (rng() - 0.5) * 0.02;
    pos.push({
      x: cx + (r + jitter) * Math.cos(ang),
      y: cy + (r + jitter) * Math.sin(ang)
    });
  }

  const edges = [];
  for (let u = 0; u < n; u++) {
    for (let v = u + 1; v < n; v++) {
      if (rng() < p) edges.push({ u, v });
    }
  }

  return { n, edges, pos };
}

function randomAssignment(n, rng) {
  const part = new Array(n);
  for (let i = 0; i < n; i++) part[i] = rng() < 0.5 ? 0 : 1;
  return part;
}

function cutValue(part, edges) {
  let c = 0;
  for (const e of edges) if (part[e.u] !== part[e.v]) c++;
  return c;
}

// Efficient delta for flipping a single vertex i:
// delta = (#neighbors in same side) - (#neighbors in other side)
// because edges incident to i that were crossing become non-crossing and vice versa.
function bestImprovingFlip(part, n, edges) {
  // Build adjacency list once per call (fine for demo sizes).
  const adj = Array.from({ length: n }, () => []);
  for (const e of edges) {
    adj[e.u].push(e.v);
    adj[e.v].push(e.u);
  }

  let best = { i: -1, delta: 0 };
  for (let i = 0; i < n; i++) {
    let same = 0, other = 0;
    for (const j of adj[i]) {
      if (part[i] === part[j]) same++; else other++;
    }
    const delta = same - other; // improvement if positive
    if (delta > best.delta) best = { i, delta };
  }
  return best;
}

function buildStepHistory(G, rng) {
  // Start from random partition; do steepest ascent until no improvement.
  const part0 = randomAssignment(G.n, rng);
  const c0 = cutValue(part0, G.edges);

  const history = [];
  history.push({
    part: part0.slice(),
    cut: c0,
    move: { type: "init", info: "Random initial partition" }
  });

  let part = part0.slice();
  let cut = c0;

  // safety cap to avoid infinite loops (shouldn't happen with strict improvement)
  const CAP = 5000;

  for (let t = 0; t < CAP; t++) {
    const best = bestImprovingFlip(part, G.n, G.edges);
    if (best.i === -1 || best.delta <= 0) {
      history.push({
        part: part.slice(),
        cut: cut,
        move: { type: "stop", info: "No improving single-vertex flip (local optimum)" }
      });
      break;
    }
    part[best.i] = 1 - part[best.i];
    cut += best.delta;

    history.push({
      part: part.slice(),
      cut: cut,
      move: { type: "flip", i: best.i, delta: best.delta, info: `Flip v${best.i} (Δcut = +${best.delta})` }
    });
  }

  return history;
}

/* ---------------------------
   Rendering
--------------------------- */
const canvas = document.getElementById("cv");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  draw();
}
window.addEventListener("resize", resizeCanvas);

function draw() {
  if (!G || steps.length === 0) {
    ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
    return;
  }

  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0, 0, w, h);

  // background subtle grid
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.04)";
  for (let x = 0; x <= w; x += 40) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
  }
  for (let y = 0; y <= h; y += 40) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
  }

  const state = steps[stepPtr];
  const part = state.part;

  const toXY = (p) => ({ x: p.x * w, y: p.y * h });

  // edges
  for (const e of G.edges) {
    const a = toXY(G.pos[e.u]);
    const b = toXY(G.pos[e.v]);
    const isCut = part[e.u] !== part[e.v];

    ctx.lineWidth = isCut ? 2.2 : 1.4;
    ctx.strokeStyle = isCut ? getCSS("--edgeCut") : getCSS("--edge");
    ctx.globalAlpha = isCut ? 1 : 1;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
  }

  // nodes
  for (let i = 0; i < G.n; i++) {
    const p = toXY(G.pos[i]);
    const r = Math.max(10, Math.min(18, 320 / G.n));

    // glow
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = part[i] === 0 ? "rgba(122,162,255,0.9)" : "rgba(54,211,153,0.9)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, r + 7, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.globalAlpha = 1;
    ctx.fillStyle = part[i] === 0 ? "rgba(122,162,255,0.85)" : "rgba(54,211,153,0.85)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fill();

    // ring
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.stroke();

    // label
    ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(i), p.x + 0.5, p.y + 0.5);
  }
}

function getCSS(varName) {
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}

/* ---------------------------
   UI wiring
--------------------------- */
const nRange = document.getElementById("nRange");
const pRange = document.getElementById("pRange");
const seedInput = document.getElementById("seedInput");
const nLabel = document.getElementById("nLabel");
const pLabel = document.getElementById("pLabel");

const genBtn = document.getElementById("genBtn");
const restartBtn = document.getElementById("restartBtn");
const backBtn = document.getElementById("backBtn");
const nextBtn = document.getElementById("nextBtn");
const playBtn = document.getElementById("playBtn");
const pauseBtn = document.getElementById("pauseBtn");

const cutValEl = document.getElementById("cutVal");
const stepIdxEl = document.getElementById("stepIdx");
const stepMaxEl = document.getElementById("stepMax");
const lastMoveEl = document.getElementById("lastMove");

function syncLabels() {
  nLabel.textContent = nRange.value;
  pLabel.textContent = (Number(pRange.value) / 100).toFixed(2);
}

function setButtons() {
  backBtn.disabled = (stepPtr <= 0);
  nextBtn.disabled = (stepPtr >= steps.length - 1);
  restartBtn.disabled = (!G);

  if (!G) {
    playBtn.disabled = true;
    pauseBtn.disabled = true;
    return;
  }

  if (playing) {
    playBtn.disabled = true;
    pauseBtn.disabled = false;
  } else {
    playBtn.disabled = false;
    pauseBtn.disabled = true;
  }
}

function updateStats() {
  if (!G || steps.length === 0) {
    cutValEl.textContent = "0";
    stepIdxEl.textContent = "0";
    stepMaxEl.textContent = "0";
    lastMoveEl.textContent = "—";
    return;
  }
  const st = steps[stepPtr];
  cutValEl.textContent = String(st.cut);
  stepIdxEl.textContent = String(stepPtr);
  stepMaxEl.textContent = String(steps.length - 1);

  if (st.move.type === "flip") {
    lastMoveEl.textContent = `Flip vertex ${st.move.i} (Δcut = +${st.move.delta})`;
  } else if (st.move.type === "init") {
    lastMoveEl.textContent = st.move.info;
  } else {
    lastMoveEl.textContent = st.move.info;
  }
}

function stopPlay() {
  playing = false;
  if (playTimer) clearInterval(playTimer);
  playTimer = null;
  setButtons();
}

function startPlay() {
  if (!G) return;
  playing = true;
  setButtons();
  playTimer = setInterval(() => {
    if (stepPtr < steps.length - 1) {
      stepPtr++;
      updateStats();
      setButtons();
      draw();
    } else {
      stopPlay();
    }
  }, 450);
}

function rebuildSearch(keepGraph) {
  stopPlay();

  const n = Number(nRange.value);
  const p = Number(pRange.value) / 100;

  const seedStr = seedInput.value.trim();
  const seed = seedStr ? hashStringToSeed(seedStr) : (Math.random() * 2**32) >>> 0;
  const rng = mulberry32(seed);

  if (!keepGraph) {
    G = generateGraph(n, p, rng);
  }

  // build a separate rng for the algorithm so "restart search" changes if no seed
  const algoSeed = seedStr ? (seed ^ 0x9e3779b9) >>> 0 : ((Math.random() * 2**32) >>> 0);
  const algoRng = mulberry32(algoSeed);

  steps = buildStepHistory(G, algoRng);
  stepPtr = 0;

  updateStats();
  setButtons();
  draw();
}

// UI events
nRange.addEventListener("input", () => { syncLabels(); });
pRange.addEventListener("input", () => { syncLabels(); });

genBtn.addEventListener("click", () => rebuildSearch(false));
restartBtn.addEventListener("click", () => rebuildSearch(true));

backBtn.addEventListener("click", () => {
  stopPlay();
  stepPtr = Math.max(0, stepPtr - 1);
  updateStats(); setButtons(); draw();
});

nextBtn.addEventListener("click", () => {
  stopPlay();
  stepPtr = Math.min(steps.length - 1, stepPtr + 1);
  updateStats(); setButtons(); draw();
});

playBtn.addEventListener("click", () => startPlay());
pauseBtn.addEventListener("click", () => stopPlay());

// init
syncLabels();
rebuildSearch(false);
resizeCanvas();
</script>
</body>
</html>
